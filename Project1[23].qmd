---
title: "Project1"
format: html
editor: visual
---

## Annie DiFrank

```{r setup, include=FALSE}
#this chunk is just to install/load needed packages 
knitr::opts_chunk$set(echo = TRUE)

# Use pacman to check whether packages are installed, if not load them
if (!require("pacman")) install.packages("pacman")
library(pacman)
pacman::p_load(tidycensus,
 dplyr,
 tidyverse,
 httr,
 jsonlite,
 purrr,
 ggplot2)

```

# Part 1: Data Processing

### In this section, we will query a PUMS API and return a nicely formatted tibble.

Process:

-   Build the appropriate URL

-   Use httr:get() to contact the website

-   Write a function to parse the data and put it into a tibble for ease

```{r}
#Build the URL 
pums_url<- "api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24"
#Get the URL data by contacting the website 
url_info<- httr::GET(pums_url)
str(url_info,max.level=1)

#Helper function to take output from GET() and turn it into a tibble 
get_tibble<- function(url_info) {
  #Parse the content
  parsed<- fromJSON(rawToChar(url_info$content))
  tibble_data<- as_tibble(parsed)
  
  #set the first row to the names of the columns 
  names(tibble_data) <- as.character(unlist(tibble_data[1,]))
  #remove the old first row 
  tibble_data<-tibble_data[-1,]
  
  return(tibble_data)
}
#testing function 
test<- get_tibble(url_info = url_info)

```

### In this section, we will write a function that allows users to query the API and change modifiers, including:

-   numeric variables

-   categorical variables

-   geography information 

```{r}
query_pums <- function(
  year = 2022,
  numeric_vars = c("AGEP", "PWGTP"),
  categorical_vars = c("SEX"),
  geography_level = "All",
  geography_filter_value = NULL
) {
  # Validate the year
  if (!(year %in% 2010:2022)) {
    stop("Year must be between 2010 and 2022")
  }
  
    # defining the numeric and categorical variable options
    num_var_options <-
      c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP","PWGTP")
    cat_var_options <-
      c("FER",
        "HHL",
        "HISPEED",
        "JWAP",
        "JWDP",
        "JWTRNS",
        "SCH",
        "SCHL",
        "SEX")
    
    # making sure the variables asked for are in this set of variables 
      if (any(!numeric_vars %in% num_var_options)) {
    stop("Invalid numeric variables provided")
      }
    
    # making sure one numeric variable other than PWGTP is included
if (length(numeric_vars) < 1) {
    stop("At least one numeric variable other than PWGTP must be provided")
}
        
   # making sure the variables asked for are in this set of variables 
    if (any(!categorical_vars %in% cat_var_options)) {
    stop("Invalid categorical variables provided")
    }
  
    # making sure at least one categorical variable is provided
  if (length(categorical_vars) < 1) {
    stop("At least one categorical variable must be provided")
  } 
  
  # specifying the geographic level
  valid_geo_levels <- c("All", "Region", "Division", "State")
  if (!(geography_level %in% valid_geo_levels)) {
    stop("Geography level is invalid")
  }
  
  #Building api url 
   api_url <- paste0(
      "https://api.census.gov/data/", 
      year, 
      "/acs/acs1/pums?get=", 
      paste(c(numeric_vars, categorical_vars), collapse = ",")
    )
   print(api_url)
    
    # Geography level (append to API URL)
  geo_for <- ""
  if (geography_level == "All") {
    # No additional parameters needed
  } else if (geography_level == "Region") {
    geo_for <- "&for=region:*"
  } else if (geography_level == "Division") {
    geo_for <- "&for=division:*"
  } else if (geography_level == "State") {
    if (!is.null(geography_filter_value)) {
      # Correctly appending the geography filter value for state
      geo_for <- paste0("&for=public%20use%20microdata%20area:*&in=", geography_filter_value)
    } else {
      geo_for <- "&for=state:*"
    }
  }
   api_url <- paste0(api_url, geo_for)
   
    # Print URL for debugging
    print(paste("API URL:", api_url))
  
  
  # Query the API
  response <- GET(api_url)
  # Parse response
  data <- content(response, as = "text") %>%
    fromJSON(flatten = TRUE) %>%
    as_tibble()
  
    #set the first row to the names of the columns 
  names(data) <- as.character(unlist(data[1,]))
  #remove the old first row 
  data<-data[-1,]
  
      # convert numeric variables to numeric values
    num_vars_tibble <- intersect(numeric_vars, names(data))
    data[num_vars_tibble] <- lapply(data[num_vars_tibble], as.numeric)
    
    # handle time variables, convert to middle of time period 
    time_variables <- c("JWAP", "JWDP", "JWMNP")
    time_vars_tibble <- intersect(time_variables, names(data))
    data[time_vars_tibble] <-
      lapply(data[time_vars_tibble], function(x) {
        as.numeric(x) / 2
      })
  
  # convert categorical variables to factors
  cat_vars_tibble <- intersect(categorical_vars, names(data))
  data[cat_vars_tibble] <- lapply(data[cat_vars_tibble], as.factor)
  
  #adding a class of 'census' to the tibble 
  class(data) <- c("census", class(data))
  
return(data)
}


#testing this 
test2 <- query_pums(
  year = 2021,
  numeric_vars = c("AGEP", "PWGTP"),
  categorical_vars = c("SEX"),
  geography_level = "All")
head(test2)
str(test2)

test3 <- query_pums(
  year = 2021,
  numeric_vars = c("AGEP"),
  categorical_vars = c("SEX"),
  geography_level = "State",
  geography_filter_value = "state:06"
)
head(test3)
str(test3)

```

### Next, we will write a function that allows the user to specify multiple years of survey data (and all the other options above)

-   This function will call the above single-year function as many times as needed and then combine the data into one final tibble. A year variable will be included in the final tibble.

```{r}
multiyear_querypums <- function(
    #paremeters accept multiple years and the other options already defined in query_pums
    years= c(2021,2022),
    numeric_vars = c("AGEP", "PWGTP"),
    categorical_vars= c("SEX"),
    geography_level="All",
    geography_filter_value = NULL
) {

  #initializing an empty tibble to store results 
  multiapi_data<- tibble()
  
  # Loop through each year and query the data
  for (year in years) {
    # Call the query_pums function for each year
    single_year_data <- query_pums(
      year = year,
      numeric_vars = numeric_vars,
      categorical_vars = categorical_vars,
      geography_level = geography_level,
      geography_filter_value = geography_filter_value
    )
    #add year column
    single_year_data <- single_year_data |> mutate(year=year)
    
    #combine data 
    multiapi_data <- bind_rows(multiapi_data, single_year_data)

}
  return(multiapi_data)
}

#Testing usage of function 
multiquery_test <- multiyear_querypums(
  years = c(2022, 2021), 
  numeric_vars = c("AGEP"), 
  categorical_vars = c("SEX"), 
  geography_level = "All"
)
head(multiquery_test)
str(multiquery_test)
```

# Part 2: Writing a summarizing function

### Here, we will process the data in the tibble appropriately.

-   Going to write a generic function for summarizing, which first involves making the tibble created in part 1 have an additional class of 'census'

-   Next, will write a custom summary function that gives us the means and std devs for our numeric variables and counts for our categorical variables

    -   If not specified, will summarize the numeric variables except PWGTP because this is actually the number of people for a particular row

    -   if not specified, will summarize all the categorical variables

```{r}
#background- analyzing plot functions
plot.function #what is used for a class=function
getS3method("plot","data.frame") #what is used for a class=data frame 
plot #generic method that specifies UseMethod("plot)

#First, we will update the above function to create the API data and make the tibble have an additional class of 'census'. Rather than repeating the lengthy function in this chunk, I have appended it to the original function

#Next, writing a custom summary function for class = census 

summary.census <- function(tibble, numeric_vars= NULL, categorical_vars=NULL) {
  
  weight_var<- "PWGTP"
  
  #default num and cat variables 
    if (is.null(numeric_vars)) {
    numeric_vars <- setdiff(names(data), c(weight_var, categorical_vars))  # Exclude PWGTP and cat variables using setdif, which takes the difference between the two vectors
    numeric_vars <- numeric_vars[sapply(data[numeric_vars], is.numeric)]
  }
  if (is.null(categorical_vars)) {
    categorical_vars <- names(data)[sapply(data, is.factor)]
  }
  
  #mean function - this will work for if there is or isnt PWGTP. if its present it will do a weighted mean 
  #function for mmean
  tib_mean <- function(x, weight) {
    sum(x * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE)
  }
  
  #function for std dev 
  tib_sd <- function(x, weight) {
    mean_x <- tib_mean(x, weight)
    sqrt(sum(weight * (x - mean_x)^2, na.rm = TRUE) / sum(weight, na.rm = TRUE))
  }
  
  
  #initialize list for results 
  summaries<- list()
  
  #summarize num vars using the helper functions 
  for (num_var in numeric_vars) {
    summaries[[num_var]] <- list(
      mean=tib_mean(tibble[[num_var]], tibble[[weight_var]]),
      sd= tib_sd(tibble[[num_var]], tibble[[weight_var]])
    )
  }
  
  #summarize cat vars using the helper functions and the table function to count categorical variables 
   for (cat_var in categorical_vars) {
    summaries[[cat_var]] <- table(tibble[[cat_var]], useNA = "ifany")
   }
  return(summaries)
}

#testing usage 
summary_test <- summary.census(
  test2,
  numeric_vars= "AGEP",
  categorical_vars = "SEX"
)
summary_test
```

-   Additionally, we will create a generic plot() function for a census class table

    ```{r}
    ggplot(test2,
    aes(x = SEX, y = AGEP, weight = PWGTP)) + geom_boxplot()
    ```

# Part 3: Ending Example